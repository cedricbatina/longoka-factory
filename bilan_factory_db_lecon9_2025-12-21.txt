ğŸ—“ï¸ Bilan â€” Factory DB (6i695q_factory_db) + LeÃ§on 9 (Kikongo) â€” 21/12/2025

Contexte & dÃ©cision dâ€™architecture
- Objectif : bÃ¢tir une â€œFactoryâ€ de contenus pÃ©dagogiques (leÃ§ons â†’ rÃ¨gles / chips / atomes / exemples / sources) rÃ©utilisable pour :
  web, mobile, livres, jeux (mots mÃªlÃ©s, mots croisÃ©sâ€¦), scripts InDesign, etc.
- On Ã©vite les ENUM (trop rigides) : tout passe par des tables de rÃ©fÃ©rence (types, sous-types, tags, relationsâ€¦).
- Les traductions du lexique (kgâ†”frâ†”en etc.) restent dans Lexikongo/Lexilingala. 
  Dans la Factory, on ne stocke des traductions que si câ€™est utile pÃ©dagogiquement (exemples, gloses dâ€™atomes â€œracinesâ€, notes de rÃ¨gles).

0) Nettoyage DB â€œlongoka_new_dbâ€ (source Longoka)
- ProblÃ¨me initial : collision de slug (ex. lesson_id 59 et 60 pointaient vers le mÃªme lesson_slug_id=120).
- RÃ©solution : correction des donnÃ©es pour avoir 1 slug par leÃ§on, puis ajout dâ€™une contrainte :
  ALTER TABLE lessons ADD UNIQUE KEY uq_lessons_lesson_slug_id (lesson_slug_id)
- VÃ©rifications : plus aucun doublon lesson_slug_id / slug en sortie de requÃªtes HAVING COUNT(*) > 1.

1) Factory DB â€” SchÃ©ma opÃ©rationnel
Tables â€œcontenu coursâ€ (pivot = lesson_ref)
- lesson_refs : rÃ©fÃ©rence externe (platform_id, course_id, lesson_id) + slug/titre/statut/visibilitÃ©.
- chips + chip_types : micro-blocs Ã©ditoriaux (objectif, rÃ¨gle, note, Ã  retenirâ€¦).
- rules + rule_types + lesson_rules : rÃ¨gles rÃ©utilisables (prosodie, orthographe, pÃ©dagogieâ€¦), reliÃ©es Ã  une leÃ§on avec un niveau dâ€™importance.
- examples : exemples (kg_text + fr_text/en_text optionnels + notes_md).

Tables â€œatomesâ€ (graphemes, syllabes, morphÃ¨mesâ€¦)
- atoms + atom_types + atom_subtypes : entitÃ©s atomiques (grapheme, syllable, stem, morpheme, word, etc.).
- lesson_atoms + lesson_atom_roles : relie les atomes Ã  une leÃ§on (core / bonus) + evidence.
- graphemes + grapheme_kinds + orthographies : inventaire de graphÃ¨mes par orthographe (kg classique).
- atom_grapheme_seq : dÃ©composition atom â†’ sÃ©quence de graphÃ¨mes (orthography_id + seq).

TraÃ§abilitÃ© / science / bibliographie
- sources + source_kinds : bibliographie.
- atom_sources : relie un atome Ã  une source + ref/quote/comment.
- tags + atom_tags : tagging extensible (etym_root, source_sungu_banzuzi, theory_*â€¦).
- theories : option â€œmodÃ¨les/thÃ©oriesâ€ (ex. Sungu Banzuzi, Nsaudiâ€¦).

Relations
- relation_types + atom_relations : liens structurants entre atomes (derived_from, composed_of, has_prefix, has_etym_root, variant_of, etc.).

2) LeÃ§on 9 (course_id=3, lesson_id=9) â€” import terminÃ©
RÃ©fÃ©rence leÃ§on
- lesson_ref_id = 1
- slug : lalphabet-du-kikongo-et-la-structure-des-mots-et-des-sons
- group : â€œLa syntaxeâ€, statut=published, visibilitÃ©=public

Volumes (contrÃ´lÃ©s via vues)
- v_lessons_overview (lesson_ref_id=1) :
  - chips : 14
  - rules : 9
  - examples : 10
  - atoms liÃ©s : 46 (20 core + 26 bonus)
  - graphemes : 20
  - syllables : 26

Chips (14) â€” thÃ¨mes
- Objectif
- Voyelles : groupes
- Ã‰pellation (ta/ata)
- Prononciation (rappels)
- Inventaire (cours)
- Tons : diacritiques
- Alternative sans diacritiques (double voyelle) â€” validÃ©e
- Norme Factory
- Diphthongues : Ã©crire ce quâ€™on prononce
- Transformations euphoniques (nasales & apostrophe)
- PiÃ¨ges frÃ©quents
- Check-list lecture correcte
- Syllabes ouvertes
- Check-list lecture (30s)

Rules (9)
- Prosodie/tons : diacritiques + rÃ¨gle â€œdouble voyelle (sans diacritiques)â€
- PÃ©dagogie : Ã©pellation ta/ata
- Orthographe : norme Factory (pas de iâ†’y / uâ†’w, on Ã©crit ce quâ€™on prononce)
- + autres rÃ¨gles liÃ©es (nasales, diphthongues, syllabes ouvertes, etc.)

Alphabet (core) â€” 20 graphÃ¨mes
- Voyelles : i u a e o
- Semi-voyelles : w y
- Consonnes : b d f g k l m n p s t v z

Syllabes-racines (bonus) â€” 26 (CV=14, CCV=12)
- CV (ex.) : ka ki ko li da de di do du pa pe pi po pu
- CCV (ex.) : nda nde ndi ndo ndu mpa mpe mpi mpo mpu ngo ngu

QualitÃ© / intÃ©gritÃ©
- orthographies : 1 ligne â€œKikongo classiqueâ€, is_default=1
- graphemes : 20
- atom_grapheme_seq : mapping OK ; check â€œsÃ©quence complÃ¨teâ€ retourne 0 anomalie.
- lesson_atoms : 20 graphemes (core) + 26 syllables (bonus)

3) Sources & thÃ©ories (Ã©tymologie / lettres)
- Source ajoutÃ©e :
  - code = sungu_banzuzi_roots (kind=book)
- atom_sources :
  - 26 syllabes liÃ©es Ã  cette source (1 lien par syllabe).
- tags / thÃ©ories :
  - Tagging dÃ©jÃ  en place pour â€œtheory_sungu_banzuziâ€ et â€œtheory_nsaudi_lettersâ€
  - RÃ©sultat actuel : 26 syllabes + 20 graphÃ¨mes taggÃ©s sur ces scopes (utile pour filtrer/afficher par â€œcadre thÃ©oriqueâ€).

4) Normes linguistiques retenues (pour Ã©viter les ambiguÃ¯tÃ©s)
- Pas dâ€™exception iâ†’y / uâ†’w : on vise une Ã©criture â€œphonÃ©tiqueâ€ stable.
- â€œDouble voyelleâ€ validÃ©e comme alternative sans diacritiques (ex. kÃ´ka â†’ kooka).
- Syllabe kikongo : ouverte (consonne(s) + voyelle), pas de consonne finale.
  => Pour les analyses, on privilÃ©gie une segmentation en syllabes (CV/CCV) plutÃ´t quâ€™en â€œlettres isolÃ©esâ€.
- Exemple : mpimpa sâ€™Ã©crit mpimpa, mais peut se prononcer [mpiimpa] (rÃ¨gle prosodique/allongement).
  => Ã€ stocker comme rule + example (et Ã©ventuellement une prononciation), pas comme â€œimâ€ syllabe autonome.

5) Ã‰tat global DB (compteurs)
- lesson_refs : 1
- chips : 14
- rules : 9
- examples : 10
- atoms : 54
- atom_relations : 5
(les vues leÃ§on montrent 46 atomes rattachÃ©s Ã  L9 ; le reste = atomes â€œfactoryâ€ non attachÃ©s / autres essais)

6) Prochaine Ã©tape recommandÃ©e (avant LeÃ§on 10)
A) Stabiliser le â€œdashboard dataâ€
- Garder les vues existantes :
  - v_lessons_overview
  - v_lesson_chips
  - v_lesson_atoms
  (+ idÃ©alement v_lesson_rules, v_lesson_examples si pas encore)

B) Ajouter 2 briques pour lâ€™usine â€œmulti-produitsâ€
1) Export JSON â€œLesson Packâ€ (idempotent)
- Donne : lesson_ref + chips + rules + examples + atoms (+ graphÃ¨mes/syllabes dÃ©composÃ©es).
- Sert de format dâ€™Ã©change pour Nuxt / mobile / InDesign / gÃ©nÃ©rateurs.

2) GÃ©nÃ©ration dâ€™exercices (plus tard, mais prÃ©vue)
- On pourra gÃ©nÃ©rer une partie des exos depuis :
  - inventaire de graphÃ¨mes/syllabes
  - rÃ¨gles (tons, ta/ata, nasalesâ€¦)
  - progression des leÃ§ons (prÃ©requis)
- Les exos â€œÃ©crits Ã  la mainâ€ restent possibles en complÃ©ment.

7) Orientation â€œJava plutÃ´t que Nuxtâ€
- On a dÃ©jÃ  un projet Java (backend-java) orientÃ© gÃ©nÃ©ration de jeux Ã  partir de Lexikongo/Lexilingala.
- Proposition : ajouter un module/paquet â€œfactoryâ€ qui lit 6i695q_factory_db et produit :
  - export JSON des leÃ§ons
  - endpoints API (optionnel ensuite)
Ainsi, Nuxt devient juste un client (dashboard), pas la source de vÃ©ritÃ©.

Fin.
